---
title: "ENCODE Splicing Analysis - Results"
author: 
- name: "Guillermo Rocamora PÃ©rez"
  affiliation: UCL
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  bookdown::html_document2:
    figure_caption: yes
    code_folding: show
    theme: paper
    highlight: haddock
    df_print: paged
    toc: true
    toc depth: 3
    toc_float: true
    number_sections: true
  md_document:
    variant: markdown_github
    toc: true
    number_sections: true
always_allow_html: true
---

```{r setup, include = FALSE}
shhh <- suppressPackageStartupMessages
shhh(library(patchwork))
shhh(library(ggnewscale))
shhh(library(here))
shhh(library(GenomicRanges))
shhh(library(doParallel))
shhh(library(foreach))
shhh(library(tidyverse))
options(dplyr.summarise.inform = FALSE)
options(lifecycle_verbosity = "warning")

source(here::here("Helper_Functions/hf_Analysis.R"))

knitr::opts_chunk$set(echo = F, warning = F, message = F, out.width="85%", fig.align = "center", dpi = 300)

print_df <- function(x, 
                     style = "html", 
                     limit = NULL, random = F, seed = NULL,
                     order = list(), autoWidth = FALSE, pageLength = 10, rownames = FALSE, compact = T,
                     full_width = F){
  if(style == "html"){
    dt_class = "display cell-border nowrap"
    if(compact) dt_class = paste0(dt_class, " compact")
    DT::datatable(x,
                  options = list(scrollX = TRUE,
                                 autoWidth = autoWidth,
                                 pageLength = pageLength,
                                 order = order),
                  class = dt_class,
                  rownames = rownames)
  }else{
    if(length(order) != 0){
      if(order[[2]] == "desc"){
        x <- x %>% dplyr::arrange(desc(.[[order[[1]]+1]]))
      }else{
        x <- x %>% dplyr::arrange(.[[order[[1]]+1]])
      }
    }
    
    if(!is.null(limit)){
      if(random){
        if(!is.null(seed)) set.seed(seed)
        x <- x %>% .[sample(1:nrow(.), limit), ]
      }else{
        x <- x %>% .[1:limit, ]
      }
    }
    
    x %>%
      kableExtra::kbl(booktabs = T, linesep = "") %>%
      kableExtra::kable_classic(full_width = full_width, "hover", "striped", html_font = "Cambria", font_size = 14) %>%
      kableExtra::row_spec(0, bold = T, font_size = 16)
  }
}

knit_output = "html"
```

```{r load-theme, echo = F, results = "asis"}
## Custom sciRmdTheme with increased width.
## Please ask guillermorocamora@gmail.com for more details.
if(knit_output == "html"){
  sciRmdTheme::set.theme(
    theme = "default",
    color = NULL,
    header.sticky = FALSE,
    list.group.icon = "arrow",
    font.family = "Arial",
    font.color = "black",
    header.color = "darkblue"
  )
}

custom_gg_theme <- theme(plot.title = element_text(size = 12, face = "bold"),
                  panel.border = ggplot2::element_rect(colour = "black", fill = NA, linewidth = 1),
                  axis.text.x = ggplot2::element_text(color = "black", size = 8, angle = 0, hjust = 0.5),
                  axis.text.y = ggplot2::element_text(color = "black", size = 8),
                  axis.title.x = ggplot2::element_text(face = "bold", size = 11, margin=margin(5,0,0,0)),
                  axis.title.y = ggplot2::element_text(face = "bold", size = 11, margin=margin(0,10,0,0)),
                  panel.grid.minor = element_line(color = "#444444", linewidth  = 0.05, linetype = 2),
                  panel.grid.major.y = element_line(color = "#444444", linewidth  = 0.05, linetype = 2),
                  panel.grid.major.x = element_line(color = "#444444", linewidth  = 0.1),
                  panel.background = element_rect(fill = "#FBFBFB"),
                  legend.title = element_text(size=12),
                  legend.text = element_text(size=10),
                  legend.position = "top",
                  legend.key = element_rect(color="black"),
                  legend.key.size = unit(1, 'lines'),
                  strip.text.x = element_text(color = "black", face = "bold", size = 9),
                  strip.background = element_rect(color="black", linewidth=1, linetype="solid"),
                  strip.text.y = element_text(color = "black", face = "bold", size = 9),
                  plot.margin = margin(0.5, 0.5, 0.2, 0.5, "cm"))

Category_levels <- c("Splicing_regulation", "Spliceosome", "NMD", "Exon_junction_complex")
Category_labels <- c("Splicing_regulation" = "Splicing Regulation",
                     "Spliceosome" = "Spliceosome",
                     "Exon_junction_complex" = "Exon junction complex", 
                     "NMD" = "Nononsense-mediated decay")
Novel_labels <- c("novel_donor" = "Novel donor",
                  "novel_acceptor" = "Novel acceptor")
novel_label_mini_names <- c("donor" = "Novel donor", "acceptor" = "Novel acceptor")
```

```{r load-theme_2, echo = F, results = "asis"}
if(knit_output == "html"){
cat('
<style type="text/css">
.dataTables_scrollHeadInner{
  width:100% !important;
}
.dataTables_scrollHeadInner table{
  width:100% !important;
}
.code-folding-btn {
  display: none;
}
h3, .h3 {
  font-size: 22px!important;
}
h4, .h4 {
  font-size: 18px!important;
}
h5, .h5 {
  font-size: 16px!important;
}
body{
  font-size: 13px;
}
</style>')
}
```

# Introduction and data used

In this study, we present the results of analysing the mis-splicing noise across different samples before and after the shRNA knockdown of a specific target gene, responsible for the production of different RNA binding proteins (RBPs). 

More precisely, from the 356 RBPs studied by *Van Nostrand et al.* in 2020 in his publication [A Large-Scale Binding and Functional Map of Human RNA Binding Proteins](https://www.nature.com/articles/s41586-020-2077-3), 115 of them were functionally categorized under the following categories: splicing regulation, spliceosome or exon junction complex. We also added a list of 118 genes classified as involved in nononsense-mediated decay processes. However, only 56 of those were also profiled by ENCODE fulfilling the following requirements:

* Need for at least 4 experiments:
    - 1 case experiment for cell line *K562*.
    - 1 case experiment for cell line *HepG2*.
    - 1 control experiment for cell line *K562*.
    - 1 control experiment for cell line *HepG2*.
* Need for 2 different samples per cell line and cluster. That is, 2 different isogenic replicates per experiment.

In total, we required 8 samples per studied RBP/NMD, divided in 4 cases and 4 controls which, at the same time, are divided in 4 cell line *HepG2* and 4 cell line *K562*.

Across this document, we will refer to each possible target gene as a project and each sample type (i.e. control or case) as clusters. That is, we will study 56 different projects, each one consisting of two clusters with 4 samples each. We will also refer as RBPs to both RBP and NMD genes.

## Execution parameters

To properly execute this `.Rmd`, we need to define some variables:

```{r data-preparation, echo = T}
# Data location
RBP_path <- here::here("RBPs/")
metadata_path <- here::here("Metadata/metadata_complete.tsv")

# Loading the metadata
metadata <- readr::read_delim(metadata_path, show_col_types = F)

target_RBPs = metadata %>% 
  dplyr::filter(if_any(c(Splicing_regulation, Spliceosome, Exon_junction_complex, NMD), ~ . != 0)) %>%
  dplyr::pull(target_gene) %>%
  unique()

metadata_RBPs <- metadata %>% 
  dplyr::filter(target_gene %in% target_RBPs) %>%
  tidyr::pivot_longer(c("Splicing_regulation", "Spliceosome", "Exon_junction_complex", "NMD"), 
                      names_to = "Category") %>%
  dplyr::filter(value == 1) %>%
  dplyr::select(-value) %>%
  dplyr::distinct(target_gene, sample_id, .keep_all = T)

required_clusters <- metadata_RBPs %>% dplyr::pull(experiment_type) %>% unique()

# Parameters of the script
overwrite_results = F

common_introns_path = here::here("variables/global_common_introns.rds")
common_novel_path = here::here("variables/global_common_novel.rds")

MSR_A_tests_path <- here::here("variables/MSR_A_tests.rds")
MSR_D_tests_path <- here::here("variables/MSR_D_tests.rds")
```

## Metadata extraction

Using the [ENCODE REST API](https://www.encodeproject.org/help/rest-api/), we automated the metadata extraction of the different experiments. By setting a series of filters in their [search portal](https://www.encodeproject.org/search/?assay_title=shRNA+RNA-seq&status=released&type=Experiment&target.investigated_as=RNA+binding+protein&replicates.library.biosample.donor.organism.scientific_name=Homo+sapiens), 
we extracted a total of 170 different target genes of the shRNA knockdown with the previous requirements. As mentioned, only 56 of those were also studied by *Van Nostrand et al.* in his publication.

The relevant metadata of the RBPs studied in this document are the following:

```{r table-metadata, echo = F}
print_df(metadata_RBPs)
```

The study of the metadata suggest that all ENCODE experiments were performed identically, and that the samples were extracted from the same two cell lines: [*K562*](https://www.cellosaurus.org/CVCL_0004) and [*HepG2*](https://www.cellosaurus.org/CVCL_0027). As such, all results can be compared between against each other.

For more information about the metadata extraction process, please refer to the corresponding repository: [ENCODE Metadata Extraction](https://github.com/guillermo1996/ENCODE_Metadata_Extraction).

# Methods

## Analysis pipeline

For each RBP/NMD target gene, the process is split in several steps:

1. **Download and extraction of BAM files**: from the [ENCODE Experiment search portal](https://www.encodeproject.org/search/?type=Experiment&control_type!=*&assay_term_name=shRNA%20knockdown%20followed%20by%20RNA-seq&status=released), the files related to each RBP/NMD are automatically downloaded, both case and control samples.

2. **Junction extraction**: all junctions are extracted using [`regtools junction extract`](https://regtools.readthedocs.io/en/latest/commands/junctions-extract/) after [sorting](http://www.htslib.org/doc/samtools-sort.html) and [indexing](http://www.htslib.org/doc/samtools-index.html) with [`samtools`](http://www.htslib.org/). A file is created for each BAM file in BED12 format.

3. **Junction annotation**: the junctions are read from the previously created files and merged into a single data.frame of read junctions. We also register the number of reads of each junction in every sample. The junctions located within the ENCODE blacklisted regions v2 are removed and the [MaxEntScan](http://hollywood.mit.edu/burgelab/maxent/Xmaxentscan_scoreseq.html) is calculated. The `junction_annot()` function from the package [`dasper`](http://www.bioconductor.org/packages/release/bioc/html/dasper.html) is used to annotate the junctions to a reference  transcriptome v105. All junctions not classified as either `novel_donor`, `novel_acceptor` or `annotated` are ignored. We also remove all junctions smaller than 25bp (base pairs) and those annotated introns that are ambiguously assigned to more than one gene.

4. **Junction pairing**: by looking for overlaps between the `novel` junctions and the `annotated` junctions for each sample, we measure the distance in bp between the novel and reference splice site. The annotated introns that are never associated to a novel junction are considered a `never misspliced junctions`.

5. **Filtering the distances**: we remove the pairings in which the novel junctions is associated to more than one reference intron across different samples. For more information about this process, please see the *methods* section in *Introverse* paper.

Next, we need to decide on a clustering method to combine and compare different samples. In this research, each cluster corresponds to a different target gene and experiment type (i.e. case and controls). As such, four samples per cluster are employed:

6. **Measuring the mis-splicing ratio**: by summing together all novel junction read counts attached to an annotated intron across all samples in which the novel splice was observed, and then dividing by the total number of reads of the annotated intron and the novel junctions across the same set of samples, we obtain a measurement of the mis-splicing ratio for an given annotated intron at both the donor splice site and the acceptor splice site. For more information about the mis-splicing ratio, please see section [MSR](#MSR).

7. **Generation of the DB**: two tables are created per each cluster: `db_introns` and `db_novel`. Each one contains the relevant information related to reference introns (including the never misspliced introns) and novel junctions. This includes the [MaxEntScan](http://hollywood.mit.edu/burgelab/maxent/Xmaxentscan_scoreseq.html) scores, the percentage of protein-coding transcripts and the classification in `u2` and `u12` introns. 

## Common annotated introns {.tabset}

In order to compare the different projects, we only considered the common annotated introns across all projects and clusters. To do so, we generated the following data.frames:

* **Common annotated intron table**: looped through every `db_introns` table and extracted only the information from the common annotated introns to all projects and clusters. To identify common annotated introns, we employed their locus (i.e. seqname:start-end:strand), since it is a unique identifier. The goal was to have the same number of annotated introns per project.

* **Common novel junction table**: looped through every `db_novel` table and extracted only the information from the novel junctions associated to common annotated introns. Thus, we first needed to calculate the common annotated intron table. Unlike before, we can have a different number of novel junctions per project or cluster.

```{r common-junctions}
# Generate a dataframe with only the common introns across all samples
common_introns <- getCommonIntrons(target_RBPs = target_RBPs,
                                   RBP_path = RBP_path,
                                   required_clusters = required_clusters,
                                   prune_columns = T,
                                   num_cores = 8,
                                   file_output = common_introns_path,
                                   overwrite = F)

# Generate a dataframe with only the novel junctions associated to the common introns.
common_novel <- getCommonNovel(target_RBPs = target_RBPs,
                               common_introns,
                               RBP_path = RBP_path,
                               required_clusters = required_clusters,
                               prune_columns = T,
                               num_cores = 8,
                               file_output = common_novel_path,
                               overwrite = F)

invisible(gc())
```

# Studied metrics

## MSR Studies {#MSR}

```{r MSR-data, include = F}
## Generate the MSR tables:
MSR_Table_Donor <- common_introns %>%
  dplyr::select(ref_junID, MSR_Donor, MSR_Acceptor, project, cluster) %>%
  tidyr::pivot_wider(
    id_cols = ref_junID,
    names_from = c("project", "cluster"),
    values_from = c("MSR_Donor")
  )
MSR_Table_Acceptor <- common_introns %>%
  dplyr::select(ref_junID, MSR_Donor, MSR_Acceptor, project, cluster) %>%
  tidyr::pivot_wider(
    id_cols = ref_junID,
    names_from = c("project", "cluster"),
    values_from = c("MSR_Acceptor")
  )

## Execute the Wilcox test:
MSR_Donor_tests <- generateMSRtests(target_RBPs = target_RBPs,
  cluster_case = "case",
  cluster_control = "control",
  MSR_Table = MSR_Table_Donor,
  num_cores = 16,
  file_output = MSR_D_tests_path,
  overwrite = F
)
MSR_Acceptor_tests <- generateMSRtests(target_RBPs = target_RBPs,
  cluster_case = "case",
  cluster_control = "control",
  MSR_Table = MSR_Table_Acceptor,
  num_cores = 16,
  file_output = MSR_A_tests_path,
  overwrite = F
)

## Add the type
MSR_Donor_tests <- addMSRcategories(MSR_Donor_tests, metadata_RBPs)
MSR_Acceptor_tests <- addMSRcategories(MSR_Acceptor_tests, metadata_RBPs)

## Add Bonferroni correction
MSR_Donor_tests <- addBonferroniCorrection(MSR_Donor_tests)
MSR_Acceptor_tests <- addBonferroniCorrection(MSR_Acceptor_tests)

## Add information
MSR_Acceptor_tests$statistical_test <- 'Wilcoxon Rank text: rstatix::wilcox_test(data, formula, paired = TRUE, alternative = "greater")'
MSR_Acceptor_tests$H0 <- "The observations MSR_A_case - MSR_A_control are symmetric about x = 0"
MSR_Acceptor_tests$H1 <- "The observations MSR_A_case - MSR_A_control are symmetric about x > 0"

MSR_Donor_tests$statistical_test <- 'Wilcoxon Rank text: rstatix::wilcox_test(data, formula, paired = TRUE, alternative = "greater")'
MSR_Donor_tests$H0 <- "The observations MSR_D_case - MSR_D_control are symmetric about x = 0"
MSR_Donor_tests$H1 <- "The observations MSR_D_case - MSR_D_control are symmetric about x > 0"
```

For each annotated intron, two Mis-Splicing Ratios ($MSR$) are calculated to provide a measurement of the mis-splicing frequency at the donor site ($MSR_D$) and acceptor site ($MSR_A$). To calculate these measurements, we first sum all of the novel donor/acceptor junction read counts and then divide by the sum of all annotated intron and novel junction read counts across the specific samples. It follows this formula:

$$
\begin{equation}
 MSR_A = \frac{\sum_{i=1}^{N}j_i}{\sum_{i=1}^{N}j_i+\sum_{i=1}^Ns_i }
\end{equation}
$$
where $j$ is the number of novel acceptor junction reads for a particular annotated intron, $s$ is the number of annotated intron reads and $N$ is the number of samples being studied. We can generate an $MSR$ table in which each row corresponds to an annotated intron and each column to a cluster. Example of the generated $MSR_A$ tables:

```{r MSR-table, echo = F}
MSR_Table_Acceptor[c(1:8, 21, 22), 1:5] %>% 
  dplyr::mutate(across(where(is.numeric), round, 3)) %>%
  `colnames<-`(c("Ref. junc. ID", "MSR_A ADAR case", "MSR_A ADAR control", 
                 "MSR_A AQR case", "MSR_A AQR control")) %>%
  print_df(style = "md") %>%
  kableExtra::column_spec(c(2, 4), border_left = T, border_right = F)
```

Once we have calculated the $MSR_A$ and $MSR_D$ for every annotated intron and every project, we use the paired Wilcoxon signed rank test to study if there is a significant variation in the median $MSR$ in cases vs. controls. To be more precise:

* Null hypothesis (H0): *the observations $MSR_{case} - MSR_{control}$ are symmetric about $\mu$ = 0*.
* Alternative hypothesis (H1): *the observations $MSR_{case} - MSR_{control}$ are symmetric about $\mu$ > 0* (i.e. the distribution of $MSR_{case} - MSR_{control}$ is greater than 0).

For every project, we will have two *p-values* (one for each splice site) to reject or not the null hypothesis in favour of the alternative hypothesis.

## Annotated intron studies

```{r, common-intron-MSP, echo = F}
common_introns_misspliced_percentage <- common_introns %>%
  dplyr::group_by(project, cluster) %>%
  dplyr::mutate(MSP = 100*(1-(sum(ref_type == "never")/n()))) %>%
  dplyr::distinct(project, cluster, MSP) %>%
  tidyr::pivot_wider(id_cols = project,
                     names_from = cluster,
                     values_from = MSP) %>%
  dplyr::mutate(difference = case - control, 
                type = ifelse(difference > 0, "increase", "decrease"),
                rMSP = (case/control -1)*100) %>%
  dplyr::ungroup() %>%
  dplyr::left_join(metadata_RBPs %>% 
                     dplyr::select(target_gene, Category) %>% 
                     dplyr::distinct(),
                   by = c("project" = "target_gene")) %>%
  dplyr::relocate(Category, .after = project)
```

For every project, we define the *MSP* as the number of mis-spliced annotated introns divided by the total number of annotated introns (i.e. the percentage of annotated introns that are found to be mis-spliced). This metric is calculated for both the control and case samples. 

$$
\begin{equation}
 MSP = \frac{\text{# Mis-spliced annotated introns}}{\text{# Annotated introns}}
\end{equation}
$$

To do so, we first count the number of annotated introns for each project (this number is the same across all projects) and the number of mis-spliced annotated introns in cases and control. We calculate the *MSP* for each cluster, and extract the difference as $MSP_{case} - MSP_{control}$.

## Novel junctions studies

There are two important statistics that we will study related to novel junctions: the number of unique novel junctions and the number of reads associated to novel junctions.

### Number of unique novel junctions

```{r common-novel-reads, echo = F, eval = T}
cluster_metadata <- metadata_RBPs %>%
  dplyr::filter(target_gene %in% (common_novel$project %>% unique())) %>%
  dplyr::group_by(target_gene, experiment_type, Category) %>%
  dplyr::summarize(total_counts = sum(read_depth))

common_novel_reads_stats <- common_novel %>%
  dplyr::group_by(project, cluster, novel_type) %>%
  dplyr::mutate(total_sum_counts = sum(novel_reads)) %>%
  dplyr::ungroup() %>%
  dplyr::select(project, novel_type, cluster, total_sum_counts) %>%
  dplyr::left_join(cluster_metadata %>% select(target_gene, experiment_type, Category, total_counts),
                   by = c("project" = "target_gene",
                          "cluster" = "experiment_type")) %>%
  dplyr::mutate(percent = total_sum_counts/total_counts * 100) %>%
  dplyr::group_by(project) %>% add_count(name = "N") %>%
  dplyr::group_by(cluster, .add = T) %>% add_count(name = "N_cluster") %>%
  dplyr::group_by(novel_type, .add = T) %>% add_count(name = "n") %>%
  dplyr::distinct()
```

For each cluster, we will measure the number of unique novel junctions associated to the common annotated introns. This measurement is calculated for the different splice sites.

We study the variation in the number of unique novel junctions for each project by dividing the number in the case samples by the number in the control sample.

$$
\begin{equation}
 \text{Variation in unique novel junctions [%]} = \left(\frac{\text{# Unique novel junction}_{case}}{\text{# Unique novel junctions}_{control}}-1\right)*100\%
\end{equation}
$$

### Novel junctions reads

To measure the percentage of novel reads, we sum all reads of the novel junctions in a given cluster and divide it by the total number of reads in the cluster. We obtain the percentage of reads that correspond to novel junctions in the cluster. 

$$
\text{Percentage of novel reads [%]}=\frac{\text{# Novel junction reads}}{\text{# Total reads}} *100\%
$$

As before, we will divide the case percentage by the control percentage to study the variation between case and control.

$$
\text{Variation in percentage of novel reads [%]}=\left(\frac{\text{Percentage of novel reads}_{case}}{\text{Percenrage of novel reads}_{control}}-1\right)*100\%
$$

# Results

## MSR Studies {.tabset}

```{r MSR-combination, include = F}
MSR_combined <- dplyr::bind_rows(
  MSR_Acceptor_tests %>% dplyr::mutate(MSR_type = "MSR_A"), 
  MSR_Donor_tests %>% dplyr::mutate(MSR_type = "MSR_D")) %>%
  dplyr::filter(p.value.bonferroni <= 0.05)
```

From the results of the paired Wilcoxon ranked test, we keep only those projects in which the null hypothesis can be rejected (i.e. p-value after Bonferroni correction $<= 0.05$). The following tables shows the results for:

* **Donor splice site**:

```{r MSR-Donor, echo = F}
MSR_combined %>%
  dplyr::filter(MSR_type == "MSR_D") %>%
  dplyr::mutate(across(c(effect_size), ~ round(.x, 3))) %>%
  dplyr::mutate(across(c(p.value.bonferroni), ~ signif(.x, 2))) %>%
  dplyr::arrange(-effect_size) %>%
  dplyr::select(Project = target_gene,
                Category = Category,
                "p-value" = p.value.bonferroni,
                "Effect size" = effect_size,
                Magnitude = magnitude) %>%
  print_df()
```

* **Acceptor splice site**:

```{r MSR-Acceptor, echo = F}
MSR_combined %>%
  dplyr::filter(MSR_type == "MSR_A") %>%
  dplyr::mutate(across(c(effect_size), ~ round(.x, 3))) %>%
  dplyr::mutate(across(c(p.value.bonferroni), ~ signif(.x, 2))) %>%
  dplyr::arrange(-effect_size) %>%
  dplyr::select(Project = target_gene,
                Category = Category,
                "p-value" = p.value.bonferroni,
                "Effect size" = effect_size,
                Magnitude = magnitude) %>%
  print_df()
```

From the previous tables, the relevant parameter is the *effect size* of the Wilcoxon paired rank test. It is calculated using the *Z* statistic and the number of annotated introns studied, but it can be directly calculated using the function `rstatix::wilcox_effsize()`. Using the interpretation found [in the functions' documentation](https://rpkgs.datanovia.com/rstatix/reference/wilcox_effsize.html), we categorize the effect size in: small, moderate and large. We can graphically represent the effect values for all projects where the null hypothesis of the Wilcoxon signed rank test is rejected.


```{r MSR-plot-2, echo = FALSE, fig.width=7.2, fig.height=7.2}
ggplot(MSR_combined %>%
         dplyr::group_by(target_gene) %>%
         dplyr::mutate(avg_effect_size = mean(effect_size)) %>%
         dplyr::group_by(Category, MSR_type) %>%
         dplyr::slice_max(order_by = avg_effect_size, n = 10) %>%
         dplyr::ungroup() %>%
         dplyr::arrange(-effect_size) %>%
         dplyr::mutate(
           target_gene = factor(target_gene, levels = .$target_gene %>% unique()),
           Category = factor(Category, levels = Category_levels))) +
  geom_bar(aes(x = target_gene, y = effect_size, fill = MSR_type),
           stat = "identity", color = "black", linewidth = 0.25, width = 0.8, position = "dodge") +
  geom_hline(data = data.frame(hline = c(0.1, 0.3, 0.5)), aes(yintercept = hline), linewidth = 0.25) +
  viridis::scale_fill_viridis(option = "viridis", discrete = T, begin = 0.20, end = 0.75,
                              name = "Splice site:",
                              labels = c("MSR_A" = "Acceptor", "MSR_D" = "Donor"),
                              guide = guide_legend(reverse = T)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.02)),
                     breaks = seq(0, 0.6, 0.1),
                     labels = c("0", "Small", "0.2", "Moderate", "0.4", "Large", "0.6")) +
  scale_x_discrete(expand = expansion(add = c(0.7, 0.7))) +
  coord_flip() +
  labs(x = "Target shRNA knockdown gene", y = "Effect size") +
  #ggtitle("Effect size by sample type and splice site") + 
  ggforce::facet_col(vars(Category), scales = "free_y", space = "free",
                     labeller = labeller(Category = Category_labels)) +
  custom_gg_theme 

#MSR_plot_dual_path <- here::here("images/Effect_size_combined.png")
#ggsave(file = MSR_plot_dual_path, width = 183, height = 228, units = "mm", dpi = 300)
```

The X-axis represents the effect size while the Y-axis shows the results for each target gene in which the median $MSR$ difference was significant. Positive effect sizes represent that the median $MSR$ in the case samples is higher than for the control samples. The colour is used for the splice site, being blue for the acceptor site and green for the donor site.

## Percentage of misspliced annotated introns

If we study now the variation in the percentage of mis-spliced annotated introns, we obtain the following table:

```{r, MSP-table, echo = F}
common_introns_misspliced_percentage %>%
  dplyr::mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  dplyr::select(-rMSP, -type) %>%
  dplyr::arrange(-difference) %>%
  `colnames<-`(c("Target gene", "Category", "MSP case [%]", 
                 "MSP control [%]", "Difference in MSP [%]")) %>%
  print_df()
```

We can also represent the results in the following graph, where the X-axis shows the `difference` column from the previous table. The Y-axis represents each target gene, divided by functional category. The colour only represents whether the variation is positive or negative.

```{r MSP-plot, echo = F, fig.width = 7.2, fig.height = 12,}
ggplot(common_introns_misspliced_percentage %>%
         dplyr::arrange(-difference, Category) %>%
         dplyr::mutate(project = factor(project, levels = .$project),
                       Category = factor(Category, levels = Category_levels)),
       aes(x = project, y = difference, label = difference, group = Category)) +
  geom_segment(aes(y = 0, x = project, yend = difference, xend = project), color = "black") +
  geom_tile(stat = "identity", aes(fill = type), linewidth = 0.5, 
            colour = "black",  width = 0.75, height = 2.2) +
  geom_text(aes(label = round(difference, 1)), size = 3) +
  scale_fill_manual(name="MSP variation",
                    labels = c("Decrease", "Increase"),
                    values = c("increase"="#84f954", "decrease"="#ff7d08"),
                    guide_legend(byrow = TRUE)) +
  coord_flip() +
  labs(x = "Target shRNA knockdown gene", y ="Difference in MSP from control to case") +
  ggtitle("Difference in percentage of misspliced annotated introns",
          subtitle = "By functional category") +
  ggforce::facet_col(vars(Category), scales = "free_y", space = "free",
                     labeller = labeller(Category = Category_labels)) +
  custom_gg_theme + theme(legend.key = element_blank())

#MSP_plot_path <- here::here("images/Difference_Misspliced_Percentage.png")
#ggsave(file = MSP_plot_path, width = 183, height = 183*12/7.2, units = "mm", dpi = 300)
```

## Number of unique novel junctions

```{r rNUN-data, echo = F}
common_novel_unique_number_relative <- common_novel_reads_stats %>%
  dplyr::ungroup() %>%
  tidyr::pivot_wider(id_cols = c(project, novel_type, Category),
                     names_from = cluster,
                     values_from = n) %>%
  dplyr::mutate(difference = case - control, 
                type = ifelse(difference > 0, "increase", "decrease"),
                rNUN = (case/control -1)*100) %>%
  dplyr::ungroup()
```

The results of the variation in the number of unique novel junctions are found in the following table:

```{r rNUN-table, echo = F}
common_novel_unique_number_relative %>%
  dplyr::mutate(across(where(is.numeric), ~ round(.x, 1))) %>%
  dplyr::select(-difference, -type, -Category) %>%
  dplyr::arrange(-rNUN) %>%
  `colnames<-`(c("Target gene", "Novel type", "# Unique novel junc. case", 
                 "# Unique novel junc. control", "Variation percent [%]")) %>%
  print_df()
```

Results are also shown in the following graph, where the X-axis shows the `variation` column from the previous table. The Y-axis represents each target gene, divided by functional category and splice site (donor and acceptor).

```{r rNUN-plot, echo = F, fig.width = 7.2, fig.height = 9,}
ggplot(common_novel_unique_number_relative %>%
         dplyr::arrange(-rNUN, Category) %>%
         dplyr::mutate(project = factor(project, levels = .[.$novel_type == "novel_donor", ]$project),
                       novel_type = factor(novel_type, levels = c("novel_donor", "novel_acceptor")),
                       Category = factor(Category, levels = Category_levels)),
       aes(x = project, y = rNUN, label = rNUN, group = Category)) +
  geom_segment(aes(y = 0, x = project, yend = rNUN, xend = project), color = "black") +
  geom_tile(stat = "identity", aes(fill = type), linewidth = 0.5, 
            colour = "black",  width = 0.75, height = 30) +
  geom_text(aes(label = round(rNUN, 0), color = Category), size = 2.5) +
  scale_fill_manual(name="Variation direction",
                    labels = c("Decrease", "Increase"),
                    values = c("increase"="#84f954", "decrease"="#ff7d08"),
                    guide_legend(byrow = TRUE)) +
  coord_flip(ylim = c(-40, 180)) +
  labs(x = "Target shRNA knockdown gene", y ="Variation from control to case [%]") +
  ggtitle("Variation in unique novel junctions",
          subtitle = "By novel junction type and functional category") +
  facet_grid(Category ~ novel_type, space = "free", scales = "free_y",
             labeller = labeller(novel_type = Novel_labels,
                                 Category = c("Splicing_regulation" = "A",
                                              "Spliceosome" = "B",
                                              "NMD" = "C",
                                              "Exon_junction_complex" = "D"))) +
  ggnewscale::new_scale_fill() +
  scale_color_manual(name = "Category",
                     values = c("black", "black", "black", "black"),
                     labels = c("Splicing_regulation" = expression(~bold("A")~"  Splicing Regulation"), 
                                "Spliceosome"= expression(~bold("B")~"  Spliceosome"),
                                "NMD" = expression(~bold("A")~"  NMD"), 
                                "Exon_junction_complex"= expression(~bold("B")~"  Exon junction complex")),
                     guide = guide_legend(order = 1, label.position = "left", 
                                          label.hjust = 0, keywidth = 0, override.aes = list(alpha = 0))) +
  custom_gg_theme + theme(strip.text.y = element_text(color = "black", face = "bold", size = 13, angle = 0), 
                         legend.position = "right",
                         legend.key = element_blank())

#rNUN_plot_path <- here::here("images/Variation_Unique_Novel_Junctions.png")
#ggsave(file = rNUN_plot_path, width = 183, height = 252, units = "mm", dpi = 300)
```

**IMPORTANT:** The novel acceptor value for target gene *AQR* cannot be represented in the same axis as the other target genes. The value goes to `r common_novel_unique_number_relative %>% filter(project == "AQR" & novel_type == "novel_acceptor") %>% pull(rNUN) %>% round()`% increase.

## Number of reads of novel junctions

```{r rNRP-data, echo = F}
common_novel_reads_stats_relative <- common_novel_reads_stats %>%
  dplyr::ungroup() %>%
  tidyr::pivot_wider(id_cols = c(project, novel_type, Category),
                     names_from = cluster,
                     values_from = percent) %>%
  dplyr::mutate(difference = case - control, 
                type = ifelse(difference > 0, "increase", "decrease"),
                rNRP = (case/control -1)*100) %>%
  dplyr::ungroup()
```

The results of the variation in the percentage of novel reads are found in the following table:

```{r rNRP-table, echo = F}
common_novel_reads_stats_relative %>%
  dplyr::mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
  dplyr::mutate(rNRP = round(rNRP, 1)) %>%
  dplyr::select(-difference, -type, -Category) %>%
  dplyr::arrange(-rNRP) %>%
  `colnames<-`(c("Target gene", "Novel type", "Novel junction reads case [%]", 
                 "Novel junction reads control[%]", "Variation percantage [%]")) %>%
  print_df()
```

Results are also shown in the following graph, where the X-axis shows the `variation` column from the previous table. The Y-axis represents each target gene, divided by functional category and splice site (donor and acceptor).

```{r rNRP-plot, echo = F, fig.width = 7.2, fig.height = 9}
ggplot(common_novel_reads_stats_relative %>%
         dplyr::arrange(-rNRP, Category) %>%
         dplyr::mutate(project = factor(project, levels = .[.$novel_type == "novel_donor", ]$project),
                       novel_type = factor(novel_type, levels = c("novel_donor", "novel_acceptor")),
                       Category = factor(Category, levels = Category_levels)),
       aes(x = project, y = rNRP, label = rNRP, group = Category)) +
  geom_segment(aes(y = 0, x = project, yend = rNRP, xend = project), color = "black") +
  geom_tile(stat = "identity", aes(fill = type), linewidth = 0.5, 
            colour = "black",  width = 0.75, height = 30) +
  geom_text(aes(label = round(rNRP, 0), color = Category), size = 2.5) +
  scale_fill_manual(name="Variation direction",
                    labels = c("Decrease", "Increase"),
                    values = c("increase"="#84f954", "decrease"="#ff7d08"),
                    guide_legend(byrow = TRUE)) +
  coord_flip(ylim = c(-50, 150)) +
  labs(x = "Target shRNA knockdown gene", y ="Variation from control to case [%]") +
  ggtitle("Variation in % Novel reads",
          subtitle = "By novel junction type and functional category") +
  facet_grid(Category ~ novel_type, space = "free", scales = "free_y",
             labeller = labeller(novel_type = Novel_labels,
                                 Category = c("Splicing_regulation" = "A",
                                              "Spliceosome" = "B",
                                              "NMD" = "C",
                                              "Exon_junction_complex" = "D"))) +
  ggnewscale::new_scale_fill() +
  scale_color_manual(name = "Category",
                     values = c("black", "black", "black", "black"),
                     labels = c("Splicing_regulation" = expression(~bold("A")~"  Splicing Regulation"), 
                                "Spliceosome"= expression(~bold("B")~"  Spliceosome"),
                                "NMD" = expression(~bold("A")~"  NMD"), 
                                "Exon_junction_complex"= expression(~bold("B")~"  Exon junction complex")),
                     guide = guide_legend(order = 1, label.position = "left", 
                                          label.hjust = 0, keywidth = 0, override.aes = list(alpha = 0))) +
  custom_gg_theme + theme(strip.text.y = element_text(color = "black", face = "bold", size = 13, angle = 0), 
                         legend.position = "right",
                         legend.key = element_blank())

#rNRP_plot_path <- here::here("images/Variation_Novel_Reads_Percentage.png")
#ggsave(file = rNRP_plot_path, width = 183, height = 254, units = "mm", dpi = 300)
```

**IMPORTANT:** The novel acceptor value for target gene *AQR* cannot be represented in the same axis as the other target genes. The value goes to `r common_novel_reads_stats_relative %>% filter(project == "AQR" & novel_type == "novel_acceptor") %>% pull(rNRP) %>% round()`% increase.

# Session info

<details>
  <summary>Show/hide</summary>

```{r reproducibility, echo = FALSE}
# Session info
library("sessioninfo")
options(width = 120)
session_info()
```

</details>
