---
title: "ENCODE Splicing Analysis - Results"
author: 
- name: "Guillermo Rocamora PÃ©rez"
  affiliation: UCL
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  bookdown::html_document2:
    figure_caption: yes
    code_folding: show
    theme: paper
    highlight: haddock
    df_print: paged
    toc: true
    toc depth: 3
    toc_float: true
    number_sections: true
  md_document:
    variant: markdown_github
    toc: true
    number_sections: true
always_allow_html: true
---

```{r setup, include = FALSE}
shhh <- suppressPackageStartupMessages
shhh(library(patchwork))
shhh(library(ggnewscale))
shhh(library(here))
shhh(library(GenomicRanges))
shhh(library(doParallel))
shhh(library(foreach))
shhh(library(tidyverse))
options(dplyr.summarise.inform = FALSE)
options(lifecycle_verbosity = "warning")

source(here::here("Helper_Functions/hf_Analysis.R"))

knitr::opts_chunk$set(echo = F, warning = F, message = F, out.width="85%", fig.align = "center", dpi = 100)

print_df <- function(x, 
                     style = "html", 
                     limit = NULL, random = F, seed = NULL,
                     order = list(), autoWidth = FALSE, pageLength = 10, rownames = FALSE, compact = T,
                     full_width = F){
  if(style == "html"){
    dt_class = "display cell-border nowrap"
    if(compact) dt_class = paste0(dt_class, " compact")
    DT::datatable(x,
                  options = list(scrollX = TRUE,
                                 autoWidth = autoWidth,
                                 pageLength = pageLength,
                                 order = order),
                  class = dt_class,
                  rownames = rownames)
  }else{
    if(length(order) != 0){
      if(order[[2]] == "desc"){
        x <- x %>% dplyr::arrange(desc(.[[order[[1]]+1]]))
      }else{
        x <- x %>% dplyr::arrange(.[[order[[1]]+1]])
      }
    }
    
    if(!is.null(limit)){
      if(random){
        if(!is.null(seed)) set.seed(seed)
        x <- x %>% .[sample(1:nrow(.), limit), ]
      }else{
        x <- x %>% .[1:limit, ]
      }
    }
    
    x %>%
      kableExtra::kbl(booktabs = T, linesep = "") %>%
      kableExtra::kable_classic(full_width = full_width, "hover", "striped", html_font = "Cambria", font_size = 14) %>%
      kableExtra::row_spec(0, bold = T, font_size = 16)
  }
}

knit_output = "html"
```

```{r load-theme, echo = F, results = "asis"}
## Custom sciRmdTheme with increased width.
## Please ask guillermorocamora@gmail.com for more details.
if(knit_output == "html"){
  sciRmdTheme::set.theme(
    theme = "default",
    color = NULL,
    header.sticky = FALSE,
    list.group.icon = "arrow",
    font.family = "Arial",
    font.color = "black",
    header.color = "darkblue"
  )
}

custom_gg_theme <- theme(
  plot.title = element_text(size = 17, face = "bold"),
  panel.border = ggplot2::element_rect(colour = "black", fill = NA, linewidth = 1),
  axis.text.x = ggplot2::element_text(color = "black", size = 8, angle = 0, hjust = 0.5),
  axis.text.y = ggplot2::element_text(color = "black", size = 8),
  axis.title.x = ggplot2::element_text(face = "bold", size = 11, margin = margin(5, 0, 0, 0)),
  axis.title.y = ggplot2::element_text(face = "bold", size = 11, margin = margin(0, 10, 0, 0)),
  panel.grid.minor = element_line(color = "#444444", linewidth = 0.05, linetype = 2),
  panel.grid.major.y = element_line(color = "#444444", linewidth = 0.05, linetype = 2),
  panel.grid.major.x = element_line(color = "#444444", linewidth = 0.1),
  panel.background = element_rect(fill = "#FBFBFB"),
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10),
  legend.position = "top",
  legend.key = element_rect(color = "black"),
  legend.key.size = unit(1, "lines"),
  strip.text.x = element_text(color = "black", face = "bold", size = 9),
  strip.background = element_rect(color = "black", linewidth = 1, linetype = "solid"),
  strip.text.y = element_text(color = "black", face = "bold", size = 9),
  plot.margin = margin(0.5, 0.5, 0.2, 0.5, "cm")
)

custom_gg_theme_subtitle <- custom_gg_theme + 
  theme(plot.subtitle=element_text(size=13, vjust = 1, color="black", margin = margin(b = 0, t = -5)),
        legend.margin=margin(b = -5))

cluster_labels <- c("case" = "Case", "control" = "Control")
novel_labels <- c("novel_donor" = "Novel Donor", "novel_acceptor" = "Novel Acceptor")
novel_mini_labels <- c("donor" = "Novel Donor", "acceptor" = "Novel Acceptor")
sequence_labels <- c("acceptor exon" = "Acceptor exon",
                     "acceptor intron" = "Acceptor intron",
                     "donor exon" = "Donor exon",
                     "donor intron" = "Donor intron")
delta_MES_labels <- c("delta MES 5'ss" = "Delta MES 5'ss", "delta MES 3'ss" = "Delta MES 3'ss")
```

```{r load-theme_2, echo = F, results = "asis"}
if(knit_output == "html"){
cat('
<style type="text/css">
.dataTables_scrollHeadInner{
  width:100% !important;
}
.dataTables_scrollHeadInner table{
  width:100% !important;
}
.code-folding-btn {
  display: none;
}
h3, .h3 {
  font-size: 22px!important;
}
h4, .h4 {
  font-size: 18px!important;
}
h5, .h5 {
  font-size: 16px!important;
}
body{
  font-size: 13px;
}
</style>')
}
```

# Background

In this report, we will study the Splicing noise for specific RBP/NMD projects. This is an extension of the analysis from `Splicing_Analysis_Results.Rmd`, please refer to that report to understand the methodology. Based on results from that analysis, we will focus this report in the following RBPs:

* **Splicing regulation**: 
    - Most impactful for splicing noise:  [EFTUD2](#EFTUD2), [U2AF2](#U2AF2), [U2AF1](#U2AF1) and [HNRNPC](#HNRNPC).
    - Less impactful for splicing noise: [DAZAP1](#DAZAP1), [ZRANB2](#ZRANB2), [SND1](#SND1) and [SRSF5](#SRSF5).
    - Medium impact on splicing noise: [NONO](#NONO), [ADAR](#ADAR), [HNRNPU](#HNRNPU) and [MATR3](#MATR3).
    
* **Spliceosome**: 
    - All RBPs are selected: [AQR](#AQR), [SF3A3](#SF3A3), [SF3B4](#SF3B4), [SNRNP200](#SNRNP200), [PRPF4](#PRPF4), [SART3](#SART3) and [SMNDC1](#SMNDC1).
    
* **Nononsense mediated decay**:
    - All projects are selected: [PABPC1](#PABPC1), [RPS19](#RPS19), [RPS3A](#RPS3A), [RPS10](#RPS10) and [EIF4G1](#EIF4G1).
    
* **Exon junction complex**:
    - All projects are selected: [EIF4A3](#EIF4A3), [MAGOH](#MAGOH).

The figure that inspired these studied RBPs:

```{r studied-RBPs, echo=FALSE, fig.cap="Studied RBPs", out.width="80%"}
knitr::include_graphics(here::here("images/Studied_RBPs.png"))
```

```{r data-preparation, echo = F}
# Data location
RBP_path <- here::here("RBPs/")
metadata_path <- here::here("Metadata/metadata_complete.tsv")
example_project <- "ADAR"

# Loading the metadata
metadata <- readr::read_delim(metadata_path, show_col_types = F)

target_RBPs <- metadata %>% 
  dplyr::filter(if_any(c(Splicing_regulation, Spliceosome, Exon_junction_complex, NMD), ~ . != 0)) %>%
  dplyr::pull(target_gene) %>%
  unique()

metadata_RBPs <- metadata %>% 
  dplyr::filter(target_gene %in% target_RBPs) %>%
  tidyr::pivot_longer(c("Splicing_regulation", "Spliceosome", "Exon_junction_complex", "NMD"), 
                      names_to = "Category") %>%
  dplyr::filter(value == 1) %>%
  dplyr::select(-value) %>%
  dplyr::distinct(target_gene, sample_id, .keep_all = T)

required_clusters <- metadata_RBPs %>% dplyr::pull(experiment_type) %>% unique()

# Parameters of the script
common_introns_path <- here::here("variables/global_common_introns.rds")
common_novel_path <- here::here("variables/global_common_novel.rds")
common_novel_MES_path <- here::here("variables/global_common_novel_MES.rds")
```

```{r common-junctions}
# Generate a dataframe with only the common introns across all samples
common_introns <- getCommonIntrons(target_RBPs = target_RBPs,
                                   RBP_path = RBP_path,
                                   required_clusters = required_clusters,
                                   prune_columns = T,
                                   num_cores = 8,
                                   file_output = common_introns_path,
                                   overwrite = F)

# Generate a dataframe with only the novel junctions associated to the common introns.
common_novel <- getCommonNovel(target_RBPs = target_RBPs,
                               common_introns,
                               RBP_path = RBP_path,
                               required_clusters = required_clusters,
                               prune_columns = T,
                               num_cores = 8,
                               file_output = common_novel_path,
                               overwrite = F)

invisible(gc())
```


# Studied metrics {.tabset}

## Distances {-}

An example of the novel junctions table obtained from the analysis can be seen in the following table:

```{r distance-example-table, echo = F}
common_novel %>% 
  dplyr::filter(project == example_project) %>%
  dplyr::filter(abs(distance) < 100) %>%
  dplyr::mutate(novel_junID = as.character(novel_junID),
                sequence = ifelse(distance < 0, "intron", "exon"),
                modulo = abs(distance) %% 3) %>%
  dplyr::select(novel_junID,
                novel_type, cluster, sequence, distance) %>%
  `colnames<-`(c("Novel jun. ID", "Novel type", "Cluster", "Sequence", "Distance [bp]")) %>%
  print_df(style = "md", limit = 10, random = T, full_width = T)
```

The distances graph is generated by counting the number of unique novel junctions at any given distance of the reference splicing site. From the list of novel junctions associated to common reference introns, we group by `novel_type` and `cluster`, count the number of entries for each distance within 30 bp into both intron and exon sequence, and represent the data in a histogram. 

For each project, different graphical representations will be presented. First, we present a histogram of the different distance values between -30 and 30 bp, with the case bars stacked on top of the control bars:

```{r distance-example-1, echo = FALSE, fig.width=7.2, fig.height=5.5}
limit_bp = 30
ggplot(common_novel %>% 
         dplyr::filter(project == example_project) %>%
         dplyr::mutate(novel_type = factor(novel_type, levels = c("novel_donor", "novel_acceptor")))) + 
  geom_histogram(aes(x = distance, fill = cluster),
                 bins = 60, binwidth = 1, position = "stack", alpha = 1,
                 color = "black", linewidth = 0.1) +
  scale_x_continuous(expand = expansion(mult = c(0, 0)), 
                     limits = c((limit_bp * -1), limit_bp), 
                     breaks = seq(-limit_bp, limit_bp, length.out = 5)) + 
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75,
                              name = "", labels = cluster_labels) + 
  labs(x = "Distance", y = "Number of unique novel junctions") + 
  ggtitle(paste0("Distance to the annotated intron"),
          subtitle = paste0("Target gene: ", example_project)) + 
  ggforce::facet_col(vars(novel_type),
                     labeller = labeller(novel_type = novel_labels)) + 
  custom_gg_theme_subtitle
```

However, this representation does not allow for an easy comparison between cases and controls because of the bar stacking. To do so, we split the graph in two more facets to represent each cluster by its own (notice the different Y-axis for the two rows):

```{r distance-example-2, echo = FALSE, fig.width=7.2, fig.height=4}
limit_bp = 30
ggplot(common_novel %>% 
         dplyr::filter(project == example_project) %>%
         dplyr::mutate(novel_type = factor(novel_type, levels = c("novel_donor", "novel_acceptor")))) + 
  geom_histogram(aes(x = distance, fill = cluster),
                 bins = 60, binwidth = 1, position = "stack", alpha = 1,
                 color = "black", linewidth = 0.1) +
  scale_x_continuous(expand = expansion(mult = c(0, 0)), 
                     limits = c((limit_bp * -1), limit_bp), 
                     breaks = seq(-limit_bp, limit_bp, length.out = 5)) + 
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75,
                              name = "", labels = cluster_labels) + 
  labs(x = "Distance", y = "Number of unique novel junctions") + 
  ggtitle(paste0("Distance to the annotated intron"),
          subtitle = paste0("Target gene: ", example_project)) + 
  facet_grid(novel_type ~ cluster, scales = "free_y",
             labeller = labeller(novel_type = novel_labels,
                                 cluster = cluster_labels)) + 
  custom_gg_theme_subtitle + theme(panel.spacing.x = unit(1, "lines"))
```

If we focus on the difference in the number of unique novel junctions between cases and controls, the last graph represent the histogram resulting from subtracting the control distances from the case distances:

```{r distance-example-3, echo = FALSE, warning=F, fig.width=7.2, fig.height=5.5}
limit_bp = 30
common_novel %>%
  dplyr::filter(project == example_project) %>%
  dplyr::filter(abs(distance) <= 1.1*limit_bp) %>%
  dplyr::group_by(novel_type, distance, cluster) %>%
  dplyr::count() %>%
  tidyr::pivot_wider(id_cols = c("novel_type", "distance"), names_from = "cluster", values_from = "n") %>%
  dplyr::mutate(case = replace_na(case, 0),
                control = replace_na(control, 0)) %>%
  dplyr::mutate(diff = case - control,
                novel_type = factor(novel_type, levels = c("novel_donor", "novel_acceptor"))) %>%
  ggplot() + 
  geom_histogram(aes(x = distance, y = diff, fill = "fill_color"), 
                 stat = "identity", color = "black", linewidth = 0.2, width = 1,
                 bins = 60, binwidth = 1) +
  scale_x_continuous(expand = expansion(mult = c(0, 0)), 
                     limits = c((limit_bp * -1), limit_bp), 
                     breaks = seq(-limit_bp, limit_bp, length.out = 5)) + 
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05))) +
  scale_fill_manual(name = "",
                    values = c("fill_color" = "#4394fd"),
                    labels = c("Case - Control"),
                    guide = guide_legend(override.aes = list(linewidth = .25))) +
  labs(x = "Distance", y = "Number of unique novel junctions") + 
  ggtitle(paste0("Distance difference to the annotated intron"),
          subtitle = paste0("Target gene: ", example_project)) + 
  ggforce::facet_col(vars(novel_type), 
                     labeller = labeller(novel_type = novel_labels)) +
  custom_gg_theme_subtitle
```

## Distances (modulo 3) {- #metric_dist_mod3}

To generate the modulo 3 graphs, we first filter by those distances smaller than 100 bp in either direction. Then, we group by `novel_type` and `cluster`, and calculate the distance in modulo 3 (i.e. the remainder from the division of the distance by 3). Once we have all novel junctions split in the four different categories with their distances in modulo 3, we calculate the percentage that each modulo 3 represents in each category. Thus, for each category:

$$
\text{mod.0 }\% = \frac{\# 0}{\#0 + \#1 + \#2}*100\%\qquad\quad \text{mod.1 }\% = \frac{\# 1}{\#0 + \#1 + \#2}*100\%\qquad\quad \text{mod.2 }\% = \frac{\# 2}{\#0 + \#1 + \#2}*100\%
$$

Here, $\#X$ represents the number of novel junctions at a modulo 3 distance equal to $X$. For example, from the information of the following table, we can focus on the `control acceptor` group, where we observe three 0s, one 1 and one 2:

```{r modulo3-example-table, echo = F}
set.seed(1)
modulo_table <- common_novel %>% 
  dplyr::filter(project == example_project) %>%
  dplyr::filter(abs(distance) < 100) %>%
  dplyr::mutate(sequence = ifelse(distance < 0, "intron", "exon"),
                modulo = abs(distance) %% 3) %>%
  dplyr::select(novel_junID,
                novel_type, cluster, sequence, distance, modulo) %>%
  dplyr::group_by(novel_type, cluster) %>%
  dplyr::mutate(group_name = paste(cluster, str_split_fixed(novel_type, "_", 2)[1, 2])) %>%
  dplyr::arrange(group_name) %>%
  .[sample(1:nrow(.), 10), ] %>%
  `colnames<-`(c("Novel jun. ID", "Novel type", "Cluster", "Sequence", "Distance [bp]", "Mod3 distance [bp]", "group_name"))

modulo_table %>%
  print_df(style = "md") %>%
  kableExtra::remove_column(7) %>%
  kableExtra::pack_rows(index = table(modulo_table$group_name)) 
```

Thus, the calculated percentage are:

$$
\text{mod.0 }\% = 60\%\qquad\quad \text{mod.1 }\% = 20\%\qquad\quad \text{mod.2 }\% = 20\%
$$

Additionally, we can further group the novel junctions by their intron/exon sequence, resulting a total of 8 categories, where the same calculation of percentages can be applied:

```{r modulo3-example-table-2, echo = F}
set.seed(0)
modulo_table <- common_novel %>% 
  dplyr::filter(project == example_project) %>%
  dplyr::filter(abs(distance) < 100) %>%
  dplyr::mutate(sequence = ifelse(distance < 0, "intron", "exon"),
                modulo = abs(distance) %% 3) %>%
  dplyr::select(novel_junID,
                novel_type, cluster, sequence, distance, modulo) %>%
  dplyr::group_by(novel_type, cluster) %>%
  dplyr::mutate(group_name = paste(cluster, str_split_fixed(novel_type, "_", 2)[1, 2], sequence)) %>%
  dplyr::arrange(group_name) %>%
  .[sample(1:nrow(.), 15), ] %>%
  `colnames<-`(c("Novel jun. ID", "Novel type", "Cluster", "Sequence", "Distance [bp]", "Mod3 distance [bp]", "group_name"))

modulo_table %>%
  print_df(style = "md") %>%
  kableExtra::remove_column(7) %>%
  kableExtra::pack_rows(index = table(modulo_table$group_name)) 
```

With the previous tables in mind, we represent them in three different ways. The first one just represents the number of unique novel junctions for each modulo 3 distance where $abs(distance) <= 100$.

```{r modulo3-example-1, echo = FALSE, fig.width=7.2, fig.height=5.5}
limit_bp = 30

modulo_df <- common_novel %>%
  dplyr::filter(project == example_project) %>%
  dplyr::filter(abs(distance) <= 100) %>%
  tidyr::separate(novel_type, c("novel", "novel_type")) %>%
  dplyr::mutate(modulo = abs(distance) %% 3,
                sequence = ifelse(distance < 0, "intron", "exon"),
                novel_type = factor(novel_type, levels = c("donor", "acceptor"))) %>%
  dplyr::select(cluster, novel_type, sequence, distance, modulo)

ggplot(modulo_df) +
  geom_bar(aes(x = modulo, fill = cluster), stat = "count",
           position = "dodge", color = "black", linewidth = 0.5) +
  ggrepel::geom_text_repel(aes(x = modulo, label = ..count.., group = cluster), stat = "count",
                           size = 4.2, color = "white", bg.color = "black", bg.r = .1, fontface = "bold",
                           vjust = 1.5, position = position_dodge(width = 0.9), force = 5) +
  scale_x_continuous(limits = c(-0.5, 2.5), breaks = c(0, 1, 2), expand = c(0, 0)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75,
                              name = "", labels = cluster_labels) +
  labs(x = "Modulo 3 of the distance", y = "Number of unique novel junctions") + 
  ggtitle(paste0("Mod.3 distance to the annotated intron"),
          subtitle = paste0("Target gene: ", example_project)) + 
  ggforce::facet_col(vars(novel_type), 
                     labeller = labeller(novel_type = novel_mini_labels)) +
  custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = 0.10))
```

We also represent the percentage that each that each distance in modulo 3 represents when grouped by `novel_type` (i.e. acceptor/donor) and `cluster` (i.e. case/control).

```{r modulo3-example-2, echo = FALSE, fig.width=7.2, fig.height=5.5}
limit_bp = 30

modulo_group_df <- modulo_df %>%
  dplyr::group_by(cluster, novel_type, modulo) %>% 
  dplyr::summarise(n = n()) %>%
  dplyr::mutate(freq = (n / sum(n) * 100))

ggplot(modulo_group_df) +
  geom_bar(aes(x = modulo, y = freq, fill = cluster), stat = "identity",
           position = "dodge", color = "black", linewidth = 0.5) +
  ggrepel::geom_text_repel(aes(x = modulo, y = freq, label = paste0(round(freq, 1), " %"), group = cluster),
                           size = 4.2, color = "white", bg.color = "black", bg.r = .1, fontface = "bold",
                           vjust = 1.5, position = position_dodge(width = 0.9), force = 5) +
  scale_x_continuous(limits = c(-0.5, 2.5), breaks = c(0, 1, 2), expand = c(0, 0)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75,
                              name = "", labels = cluster_labels) +
  labs(x = "Modulo 3 of the distance", y = "Percentage of novel junctions") + 
  ggtitle(paste0("Mod.3 Percentages: Cluster and Splice site"),
          subtitle = paste0("Target gene: ", example_project)) + 
  ggforce::facet_col(vars(novel_type), 
                     labeller = labeller(novel_type = novel_mini_labels)) +
  custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = 0.10))
```

Lastly, we represent the same data as before but taking into consideration whether it is located in the intronic or exonic sequence:

```{r modulo3-example-3, echo = FALSE, fig.width=7.2, fig.height=3}
limit_bp = 30

modulo_group_sequence_df <- modulo_df %>%
  dplyr::mutate(sequence_type = paste(novel_type, sequence)) %>%
  dplyr::group_by(cluster, sequence_type, modulo) %>% 
  dplyr::summarise(n = n()) %>%
  dplyr::mutate(freq = (n / sum(n) * 100)) %>%
  dplyr::arrange(desc(sequence_type)) %>%
  dplyr::mutate(sequence_type = factor(sequence_type, levels = .$sequence_type %>% unique))

ggplot(modulo_group_sequence_df) +
  geom_bar(aes(x = modulo, y = freq, fill = cluster), stat = "identity",
           position = "dodge", color = "black", linewidth = 0.3) +
  scale_x_continuous(breaks = c(0, 1, 2), expand = c(0, 0.2)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75,
                              name = "", labels = cluster_labels) +
  labs(x = "Modulo 3 of the distance", y = "Percentage of novel junctions") + 
  ggtitle(paste0("Mod.3 Percentages: Cluster, Splice site and Sequence"),
          subtitle = paste0("Target gene: ", example_project)) + 
  ggforce::facet_row(vars(sequence_type), 
                     labeller = labeller(sequence_type = sequence_labels)) +
  custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = 0.10),
                                   axis.title.y = element_text(size = 9))
```

## Delta MaxEntScan Score {-}

To represent the difference in MaxEntScan scores (MES), we subtract the MaxEntScan score of the annotated intron to the MaxEntScan score of a novel junction at each splice site. We obtain a table like the following, and represent the density plot of the different values for `delta_ss5score` and `delta_ss3score`:

$$
\text{Delta MES}^{5'} = \text{MES}_{ref}^{5'}-\text{MES}_{novel}^{5'}\qquad\qquad\text{Delta MES}^{3'} = \text{MES}_{ref}^{3'}-\text{MES}_{novel}^{3'}
$$

Example table with the Delta MES data:

```{r MES-example-table, echo = F}
if(!file.exists(common_novel_MES_path)){
  annotated_SR_details <- readRDS(paste0(RBP_path, "annotated_SR_details.rds"))
  common_novel_MES <- common_novel %>%
    #dplyr::filter(project == example_project) %>%
    dplyr::left_join(annotated_SR_details %>% select(junID, ss3score, ss5score),
                     by = c("novel_junID" = "junID")) %>%
    dplyr::rename(novel_ss3score = ss3score,
                  novel_ss5score = ss5score) %>%
    dplyr::left_join(annotated_SR_details %>% select(junID, ss3score, ss5score),
                     by = c("ref_junID" = "junID")) %>%
    dplyr::rename(ref_ss3score = ss3score,
                  ref_ss5score = ss5score) %>%
    dplyr::mutate(delta_ss5score = ref_ss5score - novel_ss5score,
                  delta_ss3score = ref_ss3score - novel_ss3score)
  
  common_novel_MES %>% saveRDS(common_novel_MES_path)
}else{
  common_novel_MES <- readRDS(common_novel_MES_path)
}
  
common_novel_MES %>%
  dplyr::filter(project == example_project) %>%
  dplyr::select(novel_junID, ref_junID, ref_ss5score, ref_ss3score,
                novel_ss5score, novel_ss3score, delta_ss5score, delta_ss3score) %>%
  `colnames<-`(c("Novel jun. ID", "Ref. jun. ID", "Ref. ss5score",
                 "Ref. ss3score", "Novel ss5score", "Novel ss3score",
                 "Delta ss5score", "Delta ss3score")) %>%
  dplyr::mutate(across(where(is.numeric), round, 2)) %>%
  print_df(style = "md", limit = 10, random = T, seed = 10) %>%
  kableExtra::column_spec(c(3, 5, 7), border_left = T, border_right = F)
```

As for the visual representations, the difference between the MaxEntScan scores for each splice site is shown in the X-axis. The Y-axis represents the kernel density estimate (smoothed version of a histogram). The fill colour represents cases vs. controls.

```{r delta-MES-example-1, echo=FALSE, message=F, warning = F, fig.height=4.5, fig.width=7.2}
delta_MES <- common_novel_MES %>%
  dplyr::filter(project == example_project) %>%
  tidyr::pivot_longer(c(delta_ss5score, delta_ss3score), names_to = "delta_type", values_to = "delta") %>%
  dplyr::filter(delta != 0) %>%
  dplyr::mutate(delta_type = ifelse(delta_type == "delta_ss5score", "delta MES 5'ss", "delta MES 3'ss")) %>%
  dplyr::mutate(delta_type = delta_type %>% as.factor()) %>%
  dplyr::mutate(delta_type = relevel(delta_type, ref = "delta MES 5'ss"))


ggplot(delta_MES) +
  geom_density(aes(x = delta, fill = cluster), alpha = 0.6, linewidth = 0.3, adjust = 1) +
  geom_vline(xintercept = 0) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75, name = "",
                              labels = cluster_labels) +
  labs(x = "Delta MaxEntScan score", y = "Density") +
  ggtitle(paste0("Delta MaxEntScan scores"),
          subtitle = paste0("Target gene: ", example_project)) +
  ggforce::facet_col(vars(delta_type),
                     labeller = labeller(delta_type = delta_MES_labels)) +
  custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = .05))
```

Additionally, we can also represent the difference in the kernel density estimate between case and control:

```{r delta-MES-example-2, echo=FALSE, message=F, warning = F, fig.height=4.5, fig.width=7.2}
densities_5 <- delta_MES %>%
  dplyr::filter(delta_type == "delta MES 5'ss") %>%
  dplyr::group_by(cluster, delta_type) %>%
  dplyr::summarise(d = list(density(delta, from = min(.$delta), to = max(.$delta))))
densities_3 <- delta_MES %>%
  dplyr::filter(delta_type == "delta MES 3'ss") %>%
  dplyr::group_by(cluster, delta_type) %>%
  dplyr::summarise(d = list(density(delta, from = min(.$delta), to = max(.$delta))))

delta_5 <- tibble::tibble(x = densities_5$d[[1]]$x,
                          y = densities_5$d[[1]]$y - densities_5$d[[2]]$y)
delta_3 <- tibble::tibble(x = densities_3$d[[1]]$x,
                          y = densities_3$d[[1]]$y - densities_3$d[[2]]$y)
delta_df <- rbind(delta_5 %>% dplyr::mutate(delta_type = "delta MES 5'ss"),
                  delta_3 %>% dplyr::mutate(delta_type = "delta MES 3'ss")) %>%
  dplyr::arrange(desc(delta_type)) %>%
  dplyr::mutate(delta_type = factor(delta_type, levels = c("delta MES 5'ss", "delta MES 3'ss")))

ggplot(delta_df) +
  geom_area(aes(x = x, y = y, fill = "fill_color"), position = "identity") +
  scale_fill_manual(name = "",
                    values = c("fill_color" = "#619cff"),
                    labels = c("Case - Control"),
                    guide = guide_legend(override.aes = list(linewidth = .25))) +
  geom_line(aes(x = x, y = y)) +
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.05))) +
  labs(x = "Delta MaxEntScan score", y = "Density") +
  ggtitle(paste0("Delta MaxEntScan scores"),
          subtitle = paste0("Target gene: ", example_project)) +
  ggforce::facet_col(vars(delta_type),
                     labeller = labeller(delta_type = delta_MES_labels)) +
  custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = 0.75))
```


## MSR {-}

The Mis-Splicing Ratio (MSR) is calculated in the data-analysis pipeline for each annotated intron found in the project samples. More information about the mis-splicing ratio can be found in the *Splicing Analysis Results* report. To visualize this data, we represent the density plot for MSR at the different splice sites (i.e. donor or acceptor). Example table with the MSR data:

```{r MSR-example-table, echo = F}
common_introns %>%
  dplyr::filter(project == example_project) %>%
  dplyr::select(ref_junID, cluster, ref_type, MSR_Donor, MSR_Acceptor) %>%
  dplyr::mutate(across(where(is.numeric), round, 3),
                ref_junID = as.character(ref_junID)) %>%
  `colnames<-`(c("Ref. jun, ID", "Cluster", "Ref. type", "MSR Donor", "MSR Acceptor")) %>%
  print_df(style = "md", random = T, limit = 10, seed = 2, full_width = T)
```

We represent both the distribution of mis-splicing ratio (MSR) at the donor site and the acceptor site. The X-axis represents the MSR, while the Y-axis represents the kernel density estimate.

```{r MSR-helper-functions, echo = F}
suppressWarnings(suppressMessages(library(scales)))
magnify_trans <- function(intercept, reducer) {
    trans <- function(x, i = intercept, r = reducer) {
        sapply(x, function(x) {
            if (x < i) x
            else x / r + i
        }) %>% as.numeric()
    }
    
    inv <- function(x, i = intercept, r = reducer) {
        sapply(x, function(x) {
            if(!is.na(x)) {
                if (x < i) x
                else (x - i) * r
            }
        }) %>% as.numeric()
    }
    trans_new(name = 'custom',
              transform = trans,
              inverse = inv
              )
}

plotMSR_2breaks <- function(df_tidy, MSR, MSR_density = NULL, title, type){
  round_any = function(x, accuracy, f=round){f(x/ accuracy) * accuracy}
  
  add_y_break <- function(plot, yval, n = 5) {
    p2 <- ggplot_build(plot)
    breaks <- p2$layout$panel_params[[1]]$y$breaks
    breaks <- breaks[!is.na(breaks)]
    
    plot +
      scale_y_continuous(expand = expansion(mult = c(0, 0.05)), breaks = round(sort(c(breaks, seq(0, yval, length.out = n)))))
  }
  
  if(missing(MSR_density)){
      densities <- df_tidy %>% 
      pivot_longer(cols = c("MSR_D", "MSR_A"), names_to = "MSR_type", values_to = "MSR") %>%
      group_by(MSR_type, cluster) %>% 
      summarise(d = list(density(MSR, from = min(.$MSR), to = max(.$MSR)))) %>%
      rowwise() %>%
      mutate(max = d$y %>% max) %>%
      ungroup()
    
    MSR_density <- max_density %>% filter(MSR_type == MSR) %>% select(cluster, max) %>% deframe
  }
  
  p <- ggplot(MSR_df) + 
    geom_density(aes(x = !!sym(MSR), fill = cluster), alpha = 0.5) +
    viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75, name = "",
                                labels = cluster_labels) +
    coord_trans(x = magnify_trans(intercept = 0.05, reducer = 50),
                y = magnify_trans(intercept = round_any(min(MSR_density), 100, f = ceiling), 
                                  reducer = 2*(max(MSR_density)-min(MSR_density))/min(MSR_density))) +
    geom_vline(xintercept = 0.05, linetype = 2, linewidth = 1) + 
    geom_hline(yintercept = round_any(min(MSR_density), 100, f = ceiling), linetype = 2, linewidth = 1) + 
    scale_x_continuous(breaks = c(0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.2, 0.4, 0.6, 0.8, 1.0), 
                       expand = expansion(mult = c(0.0, 0.02)), limits = c(0, 1)) +
    labs(x = paste0("Mis-splicing ratio (", MSR, ")"), y = "Density") + 
    ggtitle(paste0("Mis-splicing ratio at ", title, " site"),
          subtitle = paste0("Target gene: ", example_project)) + 
    custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = .05))
  
  add_y_break(p, round_any(min(MSR_density), 100, f = ceiling))
}

plotMSR_1break <- function(MSR_df, MSR, title){
  ggplot(MSR_df) + 
    geom_density(aes(x = !!sym(MSR), fill = cluster), alpha = 0.5) +
    viridis::scale_fill_viridis(discrete = T, begin = 0.15, end = 0.75, name = "",
                                labels = cluster_labels) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
    coord_trans(x = magnify_trans(intercept = 0.05, reducer = 50)) +
    geom_vline(aes(xintercept = 0.05), linetype = 2, linewidth = 1) + 
    scale_x_continuous(breaks = c(0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.2, 0.4, 0.6, 0.8, 1.0), 
                       expand = expansion(mult = c(0.0, 0.02)), limits = c(0, 1)) +
    labs(x = paste0("Mis-splicing ratio (", MSR, ")"), y = "Density") + 
    ggtitle(paste0("Mis-splicing ratio at ", title, " site"),
          subtitle = paste0("Target gene: ", example_project)) + 
    custom_gg_theme_subtitle + theme(legend.key = element_rect(color = "black", linewidth = .05))
}
```

```{r MSR-example-1, echo = F, message=F, warning = F, fig.height=4.5, fig.width=7.2}
MSR_df <- common_introns %>%
  dplyr::filter(project == example_project)

MSR_densities <- MSR_df %>%
  tidyr::pivot_longer(cols = c("MSR_Donor", "MSR_Acceptor"), names_to = "MSR_type", values_to = "MSR") %>%
  dplyr::group_by(MSR_type, cluster) %>% 
  dplyr::summarise(d = list(density(MSR, from = min(.$MSR), to = max(.$MSR)))) %>%
  dplyr::rowwise() %>%
  dplyr::mutate(max = d$y %>% max) %>%
  dplyr::ungroup()

for(MSR in c("MSR_Donor", "MSR_Acceptor")){
  MSR_density <- MSR_densities %>% 
    dplyr::filter(MSR_type == MSR) %>%
    dplyr::pull(max)
  
  title = ifelse(MSR == "MSR_Donor", "donor", "acceptor")
  if(max(MSR_density)/min(MSR_density) > 20){
    plotMSR_2breaks(MSR_df, MSR, MSR_density, title) %>% print()
  }else{
    plotMSR_1break(MSR_df, MSR, title) %>% print()
  }
  
  if(MSR == "MSR_D"){
    cat("<br><br><br>")
  }
}
```

Note that the distributions have a discontinuity at $x=0.05$ to better represent all possible MSR values. In some cases, a discontinuity in the Y-axis will also be present if the difference between the two sample types exceeds a predefined threshold.

## Stats {-}

Under the *Stats* subsection, we will study different statistics of the annotated introns and novel junctions:

* **Unique annotated introns:** number of annotated introns classified as never mis-spliced, mis-spliced at acceptor end, donor end or both. It is represented by cluster, so that we can study the variation in the number and percentage of never mis-spliced annotated introns.

* **Reads - annotated introns:** total reads associated to annotated introns and the percentage that they represent against the total read depth.

* **Reads - novel junctions:** total reads associated to novel junctions and the percentage that they represent against the total read depth. Results are separated by cluster.

# Results

```{r include = F}
eval_sr_high <- T
splicing_regulation_high <- c("EFTUD2", "U2AF2", "U2AF1", "HNRNPC")
eval_sr_low <- T
splicing_regulation_low <- c("DAZAP1", "ZRANB2", "SND1", "SRSF5")
eval_sr_medium <- T
splicing_regulation_medium <- c("NONO", "ADAR", "HNRNPU", "MATR3")

eval_spl <- T
spliceosome <- c("AQR", "SF3A3", "SF3B4", "SNRNP200", "PRPF4", "SART3", "SMNDC1")

eval_nmd <- T
nmd <- c("PABPC1", "RPS19", "RPS3A", "RPS10", "EIF4G1")

eval_ejc <- T
exon_junction_complex <- c("EIF4A3", "MAGOH")
```

## Splicing regulation

```{r splicing_regulation_high, eval = eval_sr_high, results = "asis"}
specific_RBPs <- splicing_regulation_high

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```

```{r splicing_regulation_low, eval = eval_sr_low, results = "asis"}
specific_RBPs <- splicing_regulation_low

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```

```{r splicing_regulation_medium, eval = eval_sr_medium, results = "asis"}
specific_RBPs <- splicing_regulation_medium

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```

## Spliceosome

```{r spliceosome, eval = eval_spl, results = "asis"}
specific_RBPs <- spliceosome

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```

## Nononsense-mediated decay

```{r nmd, eval = eval_nmd, results = "asis"}
specific_RBPs <- nmd

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```

## Exon junction complex

```{r exon_junction_complex, eval = eval_ejc, results = "asis"}
specific_RBPs <- exon_junction_complex

base_level = 2
for(i in seq(specific_RBPs)){
  example_project <- specific_RBPs[i]
  
  RBP_metadata <- metadata_RBPs %>%
    dplyr::filter(target_gene == example_project)
  project_introns <- common_introns %>%
    dplyr::filter(project == example_project)
  project_novel <- common_novel_MES %>%
    dplyr::filter(project == example_project)
  
  cat(knitr::knit_child("Template.Rmd", envir = environment(), quiet = T))
}
```